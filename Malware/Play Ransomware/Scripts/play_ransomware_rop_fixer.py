#!/usr/bin/env python3
"""
Copyright 2024 Netskope, Inc.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Written by Leandro FrÃ³es
Description: Script used to fix the anti-disassembly and ROP approach used by Play Ransomware.
"""
import re
import sys
import pefile
import struct

from capstone import Cs, CS_ARCH_X86, CS_MODE_64
from capstone.x86 import X86_OP_MEM, X86_OP_IMM

cs = Cs(CS_ARCH_X86, CS_MODE_64)
cs.detail = True
cs.skipdata = True

def get_xrefs(section_data: bytes) -> list:
    """
    Get all the cross reference addresses in the given section.
    :param section_data: The section data to look for the references.
    :return: A list with the xref addresses.
    """
    xrefs = []

    for inst in cs.disasm(section_data, 0, len(section_data)):
        if inst.mnemonic == "call" and inst.bytes[0] == 0xE8:
            offset = struct.unpack("<I", inst.bytes[1:])[0]
            func_addr = inst.address + offset + 5
            xrefs.append((func_addr, inst.address))
    
    return xrefs

def get_rop_offset(addr: bytes) -> int:
    """
    Attempt to find the value being added to the stack to perform
    the 'ROP call'
    :param addr: The location to look for the bytes.
    :return: The offset being added to the stack.
    """
    offset = 0

    for inst in cs.disasm(addr, 0, 5):
        if inst.mnemonic != "add":
            break
        if inst.operands[0].type == X86_OP_MEM and inst.operands[1].type == X86_OP_IMM:
            offset = inst.operands[1].value.imm

    return offset

def patch_rop_calls(section_data: bytes) -> dict:
    """
    Search for possible ROP calls present in the given section and
    patch them all with a JMP instruction to clean up the disassembly
    view.
    :param section_data: The section data to look for the rop calls.
    :return: A dict containing the locations and bytes used to patch
    the target section.
    """
    patches = {}
    count = 0

    # 0040109a 83042441 add dword [esp], 0x41
    # 0040109e c3       retn
    regex = b"\x83\x04\\$.\xc3"
    
    rule = re.compile(regex)
    matches = list(rule.finditer(section_data))

    if not matches:
        return {}

    print(f"[+] INFO: Searching ROP calls...") 

    xrefs = get_xrefs(section_data)

    for match in matches:
        rop_call_offset = match.start()
        # We only consider the size of the ROP call instructions
        rop_call_buffer = section_data[rop_call_offset:rop_call_offset + 5]

        offset = get_rop_offset(rop_call_buffer)

        if offset:
            count += 1

            func_xrefs = []

            for func_addr, ref in xrefs:
                if func_addr == rop_call_offset:
                    func_xrefs.append(ref)

            for ref in func_xrefs:
                jmp_inst_opcodes = b"\xE9" + int.to_bytes(offset) + b"\x00\x00\x00"
                j = 0
                for i in range(ref, ref + 5):
                    patches[i] = jmp_inst_opcodes[j]
                    j += 1

    if count:
        print(f"[+] INFO: Found {count} ROP calls")

    return patches

def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <file>")
        sys.exit(1)

    filename = sys.argv[1]

    print(f"[+] INFO: Starting analysis of {filename}")

    pe = pefile.PE(filename)

    section_data = None
    section_raw_offset = 0

    for section in pe.sections:
        if section.Name[:5] == b".text":
            section_data = section.get_data()
            section_raw_offset = section.PointerToRawData

    assert section_data is not None
    
    patches = patch_rop_calls(section_data)

    if not patches:
         print(f"[!] ERROR: No ROP calls found. Exiting...")
         sys.exit(1)

    print(f"[+] INFO: Patching file...")

    with open(filename, "rb") as f:
        file_data = bytearray(f.read())

    for i, byte in patches.items():
        file_data[section_raw_offset + i] = byte

    new_filename = filename + "_patched"

    with open(new_filename, 'wb') as f:
        f.write(file_data)
    
    print(f"[+] INFO: New file saved as {new_filename}")
    
if __name__ == "__main__":
    main()