#!/usr/bin/env python3
"""
Copyright 2024 Netskope, Inc.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Written by Leandro FrÃ³es
Description: Script used to generate the 8-byte key used to deobfuscate the Play Ransowmare strings.
"""
import sys
import pefile
import struct
import yara

play_key_gen_yara = """
    rule play_ransomware_key_gen {
        strings:
            $seed = {
                33 ??
                33 ??
                E9 ?? ?? ?? ??
                [5-6]
                33 ?? 
                89 ?? ?? 
                89 ?? ?? 
            }
            $counter = {  
                8b ?? ?? 
                83 ?? 01 
                89 ?? ?? 
                8? ?? ?? 
                3b
            }
        condition:
            $seed and $counter
    }
"""

KEY_GEN_RULE = yara.compile(source=play_key_gen_yara)

play_key_gen_old_yara = """
    rule play_ransomware_key_gen {
        strings:
            $seed = {
                33 ?? 
                b? ?? ?? ?? ?? 
                89 ?? ?? 
                89 ?? ?? 
                89 ?? ?? 
                5? 
                5?
            }
            $counter = {
                4? 
                89 ?? ?? 
                3d ?? ?? ?? ?? 
                72 bd
            }
        condition:
            $seed and $counter
    }
"""

KEY_GEN_OLD_RULE = yara.compile(source=play_key_gen_old_yara)

def is_inside_section(addr: int, 
                      section_start: int, 
                      section_end: int
                      ) -> bool:
    """
    Check if a given address is inside the given section range or not.
    :param addr: The address to check.
    :param section_start: The start of the section to check.
    :param section_end: The end of the section to check.
    :return: If the address is inside the section or not.
    """
    return section_start <= addr < section_end

def deref_data_section_ptr(target_addr: int, 
                           text_section: bytes, 
                           data_section: bytes, 
                           data_section_start: int, 
                           data_section_end: int
                           ) -> int:
    """
    Get a value within the .data section based on a .text section
    pointer.
    :param target_addr: The pointer address in the .text section.
    :param text_section: The .text section content.
    :param data_section: The .data section content.
    :param data_section_start: The start of the .data section.
    :param data_section_end: The end of the .data section.
    :return: The value within the .data section pointer.
    """
    data_addr = 0

    data_ptr = text_section[target_addr:target_addr + 4]
    data_ptr = struct.unpack("<I", data_ptr)[0]

    if is_inside_section(data_ptr, data_section_start, data_section_end):
        offset = data_ptr - data_section_start

        data_addr = data_section[offset:offset + 4]
        data_addr = struct.unpack("<I", data_addr)[0]

    return data_addr

def find_seed_and_counter(text_section: bytes, 
                          data_section: bytes, 
                          data_section_start: int, 
                          data_section_end: int
                          ) -> tuple:
    """
    Attempt to find both the hardcoded seed and counter.
    :param text_section: The .text section content
    :param data_section: The .data section content
    :param data_section_start: The start of the .data section
    :param data_section_end: The end of the .data section
    :return: The seed and counter found if any.
    """
    seed = 0
    counter = 0

    matches = KEY_GEN_RULE.match(data=text_section)

    if matches:
        for match in matches:
            for string in match.strings:
                for instance in string.instances:
                    if string.identifier == "$seed":
                        offset = 0
                        if instance.matched_length == 23:
                            offset = 11
                        else:
                            offset = 10
                        seed = deref_data_section_ptr(instance.offset + offset, 
                                                      text_section, 
                                                      data_section, 
                                                      data_section_start, 
                                                      data_section_end)
                    elif string.identifier == "$counter":
                        counter = deref_data_section_ptr(instance.offset + 14, 
                                                         text_section, 
                                                         data_section, 
                                                         data_section_start, 
                                                         data_section_end)
    else:
        # Try old patterns
        matches = KEY_GEN_OLD_RULE.match(data=text_section)

        if matches:
            for match in matches:
                for string in match.strings:
                    for instance in string.instances:
                        if string.identifier == "$seed":
                            target_addr = instance.offset + 3
                            seed = text_section[target_addr:target_addr + 4]
                            seed = struct.unpack("<I", seed)[0]
                        elif string.identifier == "$counter":
                            target_addr = instance.offset + 5
                            counter = text_section[target_addr:target_addr + 4]
                            counter = struct.unpack("<I", counter)[0]

    return seed, counter

def generate_key(seed: int, counter: int) -> int:
    """
    Generate a 8-byte key using some basic arithmetic operands based
    on a given seed and counter.
    :param seed: The seed to start the operations with.
    :param counter: The counter to use in the operations loop.
    :return: The 8-byte key generated.
    """
    x = seed
    y = 0
    i = 0

    while i < counter:
        a = (x * x) >> 32
        b = (x * y) + (x * y)
        if y:
            y = (a + b) & 0xffffffff
        else:
            y = a
        x = ((x * x) & 0xffffffff) + i
        i += 1

    key = struct.pack("<2I", *[x, y])
    key = int.from_bytes(key)

    return key

def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <file>")
        sys.exit(1)

    filename = sys.argv[1]

    pe = pefile.PE(filename)

    text_section = None
    data_section = None
    data_section_rva = 0

    for section in pe.sections:
        if section.Name[:5] == b".text":
            text_section = section.get_data()
        if section.Name[:5] == b".data":
            data_section = section.get_data()
            data_section_rva = section.VirtualAddress

    assert text_section is not None
    assert data_section is not None
    assert data_section_rva != 0

    image_base = pe.OPTIONAL_HEADER.ImageBase

    data_section_start = image_base + data_section_rva
    data_section_end = data_section_start + len(data_section)
    
    seed, counter = find_seed_and_counter(text_section, data_section, data_section_start, data_section_end)

    if not seed:
        print("[!] ERROR: Unable to find the key seed.")
        sys.exit(1)

    if not counter:
        print("[!] ERROR: Unable to find the gen key counter.")
        sys.exit(1)

    key = generate_key(seed, counter)

    print("Decoded key:", hex(key))
    
if __name__ == "__main__":
    main()